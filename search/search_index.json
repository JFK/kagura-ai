{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction to Kagura AI","text":"<p>Kagura AI is a lightweight open-source framework specialized in building and orchestrating AI Multi Agents. Through simple YAML-based configurations, it enables developers to create sophisticated agent-based systems that work together to accomplish complex tasks with higher accuracy and efficiency.</p>"},{"location":"#design-philosophy","title":"Design Philosophy","text":"<p>Kagura AI is built on a modular, state-driven architecture that prioritizes:</p> <ul> <li>Simplicity: Simple YAML configurations for complex AI systems</li> <li>Flexibility: Modular components that can be easily combined</li> <li>Type Safety: Strong typing and state validation throughout</li> <li>Maintainability: Clear separation of concerns and state management</li> </ul>"},{"location":"#core-components","title":"Core Components","text":""},{"location":"#ai-multi-agents","title":"AI Multi Agents","text":""},{"location":"#agent-types","title":"Agent Types","text":"<ul> <li>Atomic Agent: LLM-powered agents with state management and processing hooks</li> <li>Tool Agent: Task-specific data processors for independent operations</li> <li>Workflow Agent: Multi-agent workflow controller for complex task coordination</li> </ul>"},{"location":"#implementation-structure","title":"Implementation Structure","text":"<pre><code>agents/\n\u2514\u2500\u2500 agent_name/\n    \u251c\u2500\u2500 agent.yml         # Core configuration\n    \u251c\u2500\u2500 state_model.yml   # State definition (optional)\n    \u2514\u2500\u2500 tools.py          # Custom tools (optional)\n</code></pre>"},{"location":"#state-architecture","title":"State Architecture","text":"<ul> <li>Type-Safe Definitions: Pydantic models ensure data consistency</li> <li>Inter-Agent Communication: Seamless state sharing between components</li> <li>State Bindings: Defined pathways for data flow between agents</li> <li>YAML Serialization: Clear and maintainable state definitions</li> </ul>"},{"location":"#tool-integration","title":"Tool Integration","text":"<ul> <li>Custom Tools: Extend agent capabilities with custom implementations</li> <li>Processing Hooks: Pre/post hooks for flexible data handling</li> <li>External Connectors: Seamless integration with external services</li> <li>LLM Support: Connect with OpenAI, Anthropic, Ollama, Google via LiteLLM</li> </ul>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>Modular Design: Each agent operates as a self-contained unit</li> <li>Workflow Orchestration: Complex task coordination through multi-agent composition</li> <li>Type Safety: Strong typing and validation throughout the system</li> <li>Extensibility: Easy addition of custom tools and hooks</li> <li>Multilingual: Native support for multiple languages</li> </ul>"},{"location":"#get-started","title":"Get Started","text":"<p>Explore our guides to start building with Kagura AI:</p> <ul> <li>Quick Start Tutorial</li> <li>Installation Guide</li> <li>Configuration Guide</li> </ul> <p>Get Started \u2192</p>"},{"location":"en/installation/","title":"Installation","text":""},{"location":"en/installation/#prerequisites","title":"Prerequisites","text":"<ul> <li>Python 3.11+</li> <li>Redis (optional, for persistence)</li> </ul>"},{"location":"en/installation/#installation-steps","title":"Installation Steps","text":"<pre><code>uv add kagura-ai\n</code></pre>"},{"location":"en/installation/#starting-kagura","title":"Starting Kagura","text":"<p>You can start Kagura using the following command: <code>kagura</code> command to initiate system setup. After the first run, the configuration file <code>system.yml</code> will be created in <code>~/.config/kagura/</code>.</p> <pre><code>$ uv run kagura\nWelcome to Kagura AI!\nHere are some of Kagura's Zen principles:\n----------------------------------------\nHarmony is better than discord.\nExplicit is better than implicit.\nSimple is better than complex.\nComplex is better than complicated.\nComposition is better than inheritance.\nYAML is better than JSON for human configuration.\nTypes are better than any.\nErrors should never pass silently.\nUnless explicitly silenced.\nIn the face of ambiguity, refuse the temptation to guess.\nThere should be one-- and preferably only one --obvious way to do it.\nAlthough that way may not be obvious at first.\nNow is better than never.\nAlthough never is often better than *right* now.\nIf the implementation is hard to explain, it's a bad idea.\nIf the implementation is easy to explain, it may be a good idea.\nAgents should be one thing, rather than everything.\nDependencies are both necessary and a liability.\nWhile reactivity matters, thoughtfulness is key.\nAlthough practicality beats purity.\nErrors should never fail to inform.\nIn the face of many options, take the one most explicit.\nUnless that path is fraught with danger.\nBeautiful is better than ugly.\nUnderstanding is better than magic.\nAlthough black boxes are sometimes necessary.\nAgent composition should be intuitive.\nEven though agents can be complex.\nSimple tasks should be simple.\nComplex tasks should be possible.\nThe present is more important than the past.\nThe future is more important than the present.\nBut the past holds lessons we shouldn't forget.\n</code></pre>"},{"location":"en/installation/#verifying-installation","title":"Verifying Installation","text":"<p>To verify that Kagura is installed correctly, use the following command:</p> <pre><code>uv run kagura --help\n</code></pre> <p>Expected output:</p> <pre><code>Usage: kagura [OPTIONS] COMMAND [ARGS]...\n\n  Kagura AI - A flexible AI agent framework\n\nOptions:\n  --version  Show the version and exit.\n  --help     Show this message and exit.\n\nCommands:\n  chat    Start interactive chat with Kagura AI\n  create  Create a new Kagura agent\n</code></pre>"},{"location":"en/installation/#redis-setup-optional","title":"Redis Setup (Optional)","text":"<p>Redis provides persistent memory for the Kagura assistant.</p> <ol> <li>Install Redis:</li> </ol> <pre><code>sudo apt update\nsudo apt install redis-server\nsudo systemctl start redis-server\nsudo systemctl enable redis-server\n</code></pre> <ol> <li>Verify Redis installation:</li> </ol> <pre><code>redis-cli ping\n# Output: PONG\n</code></pre>"},{"location":"en/installation/#environment-variables","title":"Environment Variables","text":""},{"location":"en/installation/#api-keys","title":"API Keys","text":"<p>Kagura uses LiteLLM for LLM integration. Please refer to the LiteLLM documentation for more details.</p> <p>Export the following API keys in your environment to enable respective LLMs:</p> <pre><code>export OPENAI_API_KEY=\"your-openai-api-key\"\nexport ANTHROPIC_API_KEY=\"your-anthropic-api-key\"\nexport REPLICATE_API_KEY=\"your-replicate-api-key\"\nexport TOGETHERAI_API_KEY=\"your-togetherai-api-key\"\n</code></pre>"},{"location":"en/installation/#logging-level","title":"Logging Level","text":"<p>To set the logging level, use the following command:</p> <pre><code>export LOG_LEVEL=DEBUG  # Options: DEBUG, INFO, WARNING, ERROR\n</code></pre> <p>System Configuration \u2192</p>"},{"location":"en/kagura/","title":"Why Kagura AI?","text":"<p>The name \"Kagura\" draws inspiration from traditional Japanese performance art, reflecting key principles that guide our approach to AI Multi Agent development.</p>"},{"location":"en/kagura/#core-values-in-architecture","title":"Core Values in Architecture","text":""},{"location":"en/kagura/#harmony-in-design","title":"Harmony in Design","text":"<p>Kagura AI's architecture reflects the harmonious nature of its namesake:</p> <ul> <li>Modular Components: Like individual performers in Kagura, each agent has a specific role</li> <li>Coordinated Workflows: Agents work together in orchestrated sequences, similar to synchronized dance movements</li> <li>Balanced Integration: Technologies and tools are integrated thoughtfully, maintaining system coherence</li> </ul>"},{"location":"en/kagura/#flow-of-execution","title":"Flow of Execution","text":"<p>The framework embodies the flowing movements of Kagura:</p> <ul> <li>Smooth State Transitions: Data flows naturally between agents</li> <li>Dynamic Routing: Flexible pathways adapt to different scenarios</li> <li>Efficient Coordination: Streamlined communication between components</li> </ul>"},{"location":"en/kagura/#simplicity-and-power","title":"Simplicity and Power","text":"<p>Like Kagura's combination of simple movements into complex performances:</p> <ul> <li>Simple Configuration: YAML-based setup for sophisticated behaviors</li> <li>Composable Elements: Basic components combine for complex operations</li> <li>Clear Structure: Intuitive organization of agents and workflows</li> </ul>"},{"location":"en/kagura/#technical-foundation","title":"Technical Foundation","text":""},{"location":"en/kagura/#agent-architecture","title":"Agent Architecture","text":"<p>The spiritual aspects of Kagura inspire practical technical decisions:</p> <ul> <li>Independent Agents: Self-contained units with clear responsibilities</li> <li>Collaborative Systems: Agents working together toward common goals</li> <li>Adaptive Workflows: Flexible response to changing requirements</li> </ul>"},{"location":"en/kagura/#state-management","title":"State Management","text":"<p>Maintaining balance through careful state handling:</p> <ul> <li>Type Safety: Ensuring data integrity across the system</li> <li>Clear Communication: Well-defined paths for information flow</li> <li>Consistent Behavior: Predictable and reliable agent interactions</li> </ul>"},{"location":"en/kagura/#framework-vision","title":"Framework Vision","text":"<p>Kagura AI aims to embody both technical excellence and thoughtful design:</p> <ul> <li>Practical Efficiency: Streamlined development of AI Multi Agent systems</li> <li>Sustainable Growth: Easily extensible architecture for future needs</li> <li>Community Focus: Open source collaboration fostering innovation</li> </ul> <p>By combining these elements, Kagura AI creates a framework that is both powerful and accessible, enabling developers to build sophisticated AI Multi Agent systems while maintaining clarity and purpose in their design.</p>"},{"location":"en/quickstart/","title":"Quick Start","text":""},{"location":"en/quickstart/#installation-steps","title":"Installation Steps","text":"<pre><code>uv add kagura-ai\n</code></pre>"},{"location":"en/quickstart/#kagura-chatbot","title":"Kagura Chatbot","text":"<p>Start Kagura AI Chatbot:</p> <p>To start the Kagura chatbot, use the following command:</p> <pre><code>kagura chat\n</code></pre> <p>During the chat session, you can use the following commands:</p> <ul> <li><code>/help</code>: Show available commands and usage instructions.</li> <li><code>/clear</code>: Clear the current chat history.</li> <li><code>/history</code>: View the current chat history.</li> <li><code>/system</code>: Display system information and configuration settings.</li> <li><code>/agents</code>: List available agents and their descriptions.</li> <li><code>/exit</code>: Exit the chat session.</li> </ul>"},{"location":"en/quickstart/#creating-an-agent","title":"Creating an Agent","text":""},{"location":"en/quickstart/#step-1-create-agent-directory","title":"Step 1: Create Agent Directory","text":"<p>Create a directory for your agent configuration: <pre><code>mkdir -p ~/.config/kagura/agents/my_agent\n</code></pre></p>"},{"location":"en/quickstart/#step-2-define-basic-agent-configuration","title":"Step 2: Define Basic Agent Configuration","text":"<p>Create an <code>agent.yml</code> file in the newly created directory: <pre><code># ~/.config/kagura/agents/my_agent/agent.yml\ncat &gt; ~/.config/kagura/agents/my_agent/agent.yml &lt;&lt;EOF\ntype: atomic  # atomic, tool, or composite\nllm:\n  stream: true\nskip_state_model: true  # must be set to true if response_fields is not defined or there is no state_model.yml\ndescription:\n  - language: en\n    text: This is the default agent.\n  - language: ja\n    text: \u30c7\u30d5\u30a9\u30eb\u30c8\u306e\u30a8\u30fc\u30b8\u30a7\u30f3\u30c8\u3067\u3059\u3002\ninstructions:\n  - language: en\n    description: |\n      You will always respond in English.\n  - language: ja\n    description: |\n      \u3042\u305f\u306a\u305f\u306f\u3001\u5fc5\u305a\u65e5\u672c\u8a9e\u3067\u8fd4\u7b54\u3057\u307e\u3059\u3002\nprompt:\n  - language: en\n    template: |\n      {QUERY}\n  - language: ja\n    template: |\n      {QUERY}\nEOF\n</code></pre></p>"},{"location":"en/quickstart/#step-3-use-the-agent-in-your-code","title":"Step 3: Use the Agent in Your Code","text":"<p>To interact with the agent programmatically, use the following Python code:</p> <pre><code>cat &gt; my_chat.py &lt;&lt;EOF\nfrom kagura.core.agent import Agent\n\nasync def chat():\n    # Assign the created agent by its directory name\n    agent = Agent.assigner(\"my_agent\")\n    # Send a query and stream the responses\n    async for response in await agent.execute(\"Tell me about AI\"):\n        print(response, end=\"\")\n\nif __name__ == \"__main__\":\n    import asyncio\n    asyncio.run(chat())\nEOF\n</code></pre>"},{"location":"en/quickstart/#step-4-run-the-python-script","title":"Step 4: Run the Python Script","text":"<pre><code>uv run my_chat.py\n</code></pre>"},{"location":"en/quickstart/#expected-output","title":"Expected Output","text":"<p>When you run the Python script, the agent will respond to your query, for example: <pre><code>Artificial Intelligence (AI) refers to the simulation of human intelligence...\n</code></pre></p> <p>AI Agents Overview \u2192</p>"},{"location":"en/system-configuration/","title":"System Configuration","text":"<p>Create <code>system.yml</code> in <code>~/.config/kagura/</code>:</p> <pre><code>system:\n  language: en\nprompt:\n  instructions:\n    - language: en\n      description: |\n        Your name is Kagura.\n        You will always respond in English.\n    - language: ja\n      description: |\n        \u3042\u306a\u305f\u306e\u540d\u524d\u306f\u3001\u795e\u697d\uff08\u304b\u3050\u3089\uff09\u3067\u3059\u3002\n        \u3042\u305f\u306a\u305f\u306f\u3001\u5fc5\u305a\u65e5\u672c\u8a9e\u3067\u8fd4\u7b54\u3057\u307e\u3059\u3002\nmemory:\n  message_history:\n    history_uuid: kagura_personal_chat\n    window_size: 1000\n    context_window: 20\n    ttl_hours: 24\n  backend:\n    default_ttl_hours: 24\n    cleanup_interval_hours: 1\nllm:\n  model: openai/gpt-4o-mini\n  max_tokens: 4096\n  retry_count: 3\nbackends:\n - name: redis\n   host: localhost\n   port: 6379\n   db: 0\n</code></pre>"},{"location":"en/system-configuration/#field-descriptions","title":"Field Descriptions","text":"<p>system:</p> <ul> <li><code>language</code>: Defines the default language for system instructions. Supported values include <code>en</code> (English) and <code>ja</code> (Japanese).</li> </ul> <p>prompt:</p> <ul> <li><code>instructions</code>: A list of language-specific instructions describing how the assistant should behave.</li> <li><code>language</code>: Specifies the language of the instruction.</li> <li><code>description</code>: Detailed instructions for the assistant's behavior.</li> </ul> <p>memory.message_history:</p> <ul> <li><code>history_uuid</code>: Unique identifier for the chat history.</li> <li><code>window_size</code>: Number of messages to store in history.</li> <li><code>context_window</code>: Number of messages to consider as context for responses.</li> <li><code>ttl_hours</code>: Time-to-live for the chat history in hours.</li> </ul> <p>memory.backend:</p> <ul> <li><code>default_ttl_hours</code>: Default time-to-live for memory storage.</li> <li><code>cleanup_interval_hours</code>: Interval in hours for cleaning up memory storage.</li> </ul> <p>llm:</p> <ul> <li><code>model</code>: The LLM model to use (e.g., <code>openai/gpt-4o-mini</code>).</li> <li><code>max_tokens</code>: Maximum number of tokens the model can generate per response.</li> <li><code>retry_count</code>: Number of retry attempts in case of model failure.</li> </ul> <p>backends:</p> <p>List of backend services for storage or processing.</p> <ul> <li><code>name</code>: Name of the backend (e.g., <code>redis</code>).</li> <li><code>host</code>: Host address of the backend.</li> <li><code>port</code>: Port number for the backend service.</li> <li><code>db</code>: Database index to use in the backend.</li> </ul>"},{"location":"en/system-configuration/#supported-llm-providers","title":"Supported LLM Providers","text":"<p>Kagura supports multiple providers via LiteLLM:</p> <ul> <li>OpenAI (<code>openai/gpt-4</code>, <code>openai/gpt-3.5-turbo</code>)</li> <li>Anthropic (<code>anthropic/claude-3-opus</code>, <code>anthropic/claude-3-sonnet</code>)</li> <li>Ollama (<code>ollama/llama3.2</code>, <code>ollama/gemma2.5</code>)</li> <li>Google (<code>google/gemini-pro</code>)</li> </ul> <p>For a complete list of supported providers, see the LiteLLM Documentation.</p>"},{"location":"en/system-configuration/#ai-agents-configuration","title":"AI Agents Configuration","text":"<p>For a detailed explanation of agent-related settings, refer to the AI Agents Overview:</p> <p>Quick Start \u2192</p>"},{"location":"en/advanced/state-management/","title":"State Management in Kagura AI","text":""},{"location":"en/advanced/state-management/#introduction","title":"Introduction","text":"<p>Kagura AI's state management system has been enhanced with INPUT_QUERY and TEXT_OUTPUT fields to provide clearer separation between inputs and outputs while maintaining state consistency. This guide explains how to effectively use these features in your agents.</p>"},{"location":"en/advanced/state-management/#core-concepts","title":"Core Concepts","text":""},{"location":"en/advanced/state-management/#input_query","title":"INPUT_QUERY","text":"<ul> <li>Stores structured input field data</li> <li>Preserves original input context</li> <li>Enables input tracking and validation</li> </ul>"},{"location":"en/advanced/state-management/#text_output","title":"TEXT_OUTPUT","text":"<ul> <li>Stores converted response text</li> <li>Provides standardized output format</li> <li>Facilitates response processing</li> </ul>"},{"location":"en/advanced/state-management/#implementation-example","title":"Implementation Example","text":""},{"location":"en/advanced/state-management/#basic-agent-configuration","title":"Basic Agent Configuration","text":"<pre><code># agent.yml\ninput_fields:\n  - text_input\n  - parameters\n\nresponse_fields:\n  - analysis_result\n  - summary\n</code></pre> <pre><code># state_model.yml\nstate_fields:\n  - name: text_input\n    type: str\n    description:\n      - language: en\n        text: Input text for processing\n  - name: parameters\n    type: Dict[str, Any]\n    description:\n      - language: en\n        text: Processing parameters\n  - name: analysis_result\n    type: str\n    description:\n      - language: en\n        text: Analysis output\n  - name: summary\n    type: str\n    description:\n      - language: en\n        text: Summarized results\n</code></pre>"},{"location":"en/advanced/state-management/#using-state-management","title":"Using State Management","text":"<pre><code>from kagura.core.agent import Agent\n\nasync def process_text():\n    # Initialize agent with input data\n    input_data = {\n        \"text_input\": \"Sample text for analysis\",\n        \"parameters\": {\"depth\": \"detailed\"}\n    }\n\n    agent = Agent.assigner(\"text_analyzer\", input_data)\n    result = await agent.execute()\n\n    # Access stored input\n    print(\"Input Data:\", result.INPUT_QUERY)\n\n    # Access converted output\n    print(\"Text Output:\", result.TEXT_OUTPUT)\n\n    # Access specific fields\n    print(\"Analysis:\", result.analysis_result)\n    print(\"Summary:\", result.summary)\n</code></pre>"},{"location":"en/advanced/state-management/#best-practices","title":"Best Practices","text":""},{"location":"en/advanced/state-management/#1-input-field-storage","title":"1. Input Field Storage","text":"<ul> <li>Store all input fields in INPUT_QUERY</li> <li>Validate input data structure</li> <li>Maintain input field relationships</li> </ul>"},{"location":"en/advanced/state-management/#2-text-output-conversion","title":"2. Text Output Conversion","text":"<ul> <li>Convert complex responses to readable text</li> <li>Handle different data types appropriately</li> <li>Maintain output consistency</li> </ul>"},{"location":"en/advanced/state-management/#3-state-consistency","title":"3. State Consistency","text":"<ul> <li>Keep INPUT_QUERY and TEXT_OUTPUT synchronized</li> <li>Handle state transitions cleanly</li> <li>Validate state at each step</li> </ul>"},{"location":"en/advanced/state-management/#advanced-features","title":"Advanced Features","text":""},{"location":"en/advanced/state-management/#custom-text-conversion","title":"Custom Text Conversion","text":"<p>You can customize how responses are converted to text by modifying the <code>_convert_response_to_text</code> method:</p> <pre><code>async def _convert_response_to_text(self) -&gt; str:\n    \"\"\"Custom text conversion logic\"\"\"\n    text_parts = []\n\n    for field in self.response_fields:\n        value = getattr(self._state, field)\n        if isinstance(value, str):\n            text_parts.append(value)\n        elif isinstance(value, (list, dict)):\n            text_parts.append(\n                json.dumps(value, indent=2, ensure_ascii=False)\n            )\n        elif isinstance(value, BaseModel):\n            text_parts.append(\n                value.model_dump_json(indent=2)\n            )\n\n    return \"\\n\\n\".join(text_parts)\n</code></pre>"},{"location":"en/advanced/state-management/#state-validation","title":"State Validation","text":"<p>Implement custom validation for your state:</p> <pre><code>from pydantic import validator\n\nclass MyStateModel(BaseStateModel):\n    @validator('INPUT_QUERY')\n    def validate_input_query(cls, v):\n        if not v.get('required_field'):\n            raise ValueError(\"Missing required field\")\n        return v\n</code></pre>"},{"location":"en/advanced/state-management/#testing","title":"Testing","text":""},{"location":"en/advanced/state-management/#example-test-cases","title":"Example Test Cases","text":"<pre><code>@pytest.mark.asyncio\nasync def test_state_management():\n    agent = Agent.assigner(\"my_agent\")\n    input_data = {\n        \"text_input\": \"Test input\",\n        \"parameters\": {\"key\": \"value\"}\n    }\n\n    result = await agent.execute(input_data)\n\n    # Verify INPUT_QUERY storage\n    assert result.INPUT_QUERY[\"text_input\"] == \"Test input\"\n    assert result.INPUT_QUERY[\"parameters\"][\"key\"] == \"value\"\n\n    # Verify TEXT_OUTPUT conversion\n    assert result.TEXT_OUTPUT is not None\n    assert isinstance(result.TEXT_OUTPUT, str)\n</code></pre>"},{"location":"en/advanced/state-management/#common-patterns","title":"Common Patterns","text":""},{"location":"en/advanced/state-management/#1-input-processing","title":"1. Input Processing","text":"<pre><code>def process_input(state: BaseStateModel) -&gt; None:\n    # Access stored input data\n    input_data = state.INPUT_QUERY\n\n    # Process specific fields\n    text_input = input_data.get(\"text_input\", \"\")\n    parameters = input_data.get(\"parameters\", {})\n\n    # Perform validation or transformation\n    if not text_input:\n        raise ValueError(\"Text input is required\")\n</code></pre>"},{"location":"en/advanced/state-management/#2-output-formatting","title":"2. Output Formatting","text":"<pre><code>def format_output(state: BaseStateModel) -&gt; None:\n    # Generate formatted output\n    formatted_text = []\n\n    # Add analysis results\n    if state.analysis_result:\n        formatted_text.append(f\"Analysis: {state.analysis_result}\")\n\n    # Add summary\n    if state.summary:\n        formatted_text.append(f\"Summary: {state.summary}\")\n\n    # Update TEXT_OUTPUT\n    state.TEXT_OUTPUT = \"\\n\".join(formatted_text)\n</code></pre>"},{"location":"en/advanced/state-management/#troubleshooting","title":"Troubleshooting","text":""},{"location":"en/advanced/state-management/#common-issues","title":"Common Issues","text":"<ol> <li>Missing Input Data</li> <li>Verify all required input fields are provided</li> <li>Check INPUT_QUERY structure</li> <li> <p>Validate input data types</p> </li> <li> <p>Text Conversion Errors</p> </li> <li>Check response field definitions</li> <li>Verify data type handling</li> <li> <p>Review text conversion logic</p> </li> <li> <p>State Consistency</p> </li> <li>Ensure state transitions are handled</li> <li>Verify field updates</li> <li>Check validation rules</li> </ol>"},{"location":"en/advanced/state-management/#best-practices-summary","title":"Best Practices Summary","text":"<ol> <li>Always validate input data before processing</li> <li>Maintain clear separation between input and output states</li> <li>Use type hints and validation for better reliability</li> <li>Document state transitions and transformations</li> <li>Implement comprehensive error handling</li> <li>Write tests for state management logic</li> <li>Keep input and output structures consistent</li> <li>Use appropriate data types for state fields</li> <li>Handle state cleanup properly</li> <li>Monitor state changes for debugging</li> </ol>"},{"location":"en/advanced/state-management/#future-considerations","title":"Future Considerations","text":"<ol> <li>State History Tracking</li> <li>Enhanced Validation Rules</li> <li>Custom Serialization Formats</li> <li>State Migration Support</li> <li>Performance Optimization</li> </ol>"},{"location":"en/agents/configuration/","title":"Agent Configuration","text":"<p>Kagura agents are configured using YAML files, allowing you to define their roles, behavior, and state models. This document provides an overview of the configuration structure and examples for each agent type.</p>"},{"location":"en/agents/configuration/#configuration-basics","title":"Configuration Basics","text":"<p>Each agent requires at least one YAML file:</p> <ol> <li><code>agent.yml</code>: Defines the agent's behavior, prompts, and tools.</li> </ol> <p>For Atomic Agent and Tool Agent, an optional <code>state_model.yml</code> can be used to specify the state model. Orchestrator Agent dose not require a <code>state_model.yml</code> as they rely on predefined Atomic Agent and Tool Agent configurations.</p>"},{"location":"en/agents/configuration/#directory-structure","title":"Directory Structure","text":"<pre><code>agents/\n\u2514\u2500\u2500 agent_name/\n    \u251c\u2500\u2500 agent.yml         # Core configuration\n    \u251c\u2500\u2500 state_model.yml   # State definition\n    \u2514\u2500\u2500 tools.py          # Custom tools\n</code></pre>"},{"location":"en/agents/configuration/#agentyml","title":"agent.yml","text":"<p>The <code>agent.yml</code> file defines the agent's role, behavior, and processing logic.</p>"},{"location":"en/agents/configuration/#key-configuration-fields","title":"Key Configuration Fields","text":""},{"location":"en/agents/configuration/#atomic-agent","title":"Atomic Agent","text":"<ul> <li><code>llm</code>: Configuration for the language model (e.g., <code>model</code>, <code>max_tokens</code>, <code>retry_count</code>).</li> <li><code>response_fields</code>: Specifies the expected output fields of the agent. Each field listed here must also be included in the <code>state_model.yml</code> under <code>state_fields</code> to ensure consistency.</li> <li><code>post_custom_tool</code>: Specifies a custom tool to be executed as a post-processing hook for state data.</li> <li><code>pre_custom_tool</code>: Specifies a custom tool to be executed as a pre-processing hook for state data.</li> </ul>"},{"location":"en/agents/configuration/#tool-agent","title":"Tool Agent","text":"<ul> <li><code>custom_tool</code>: Defines the path to a custom tool that the agent will use. This is the primary configuration field for Tool Agents, allowing them to execute custom logic for specific tasks.</li> <li><code>response_fields</code>: Required when specifying the fields that the tool is expected to produce. These fields must align with the <code>state_model.yml</code> definitions for consistency.</li> </ul>"},{"location":"en/agents/configuration/#orchestrator-agent","title":"Orchestrator Agent","text":"<ul> <li><code>entry_point</code>: Specifies the starting node in a workflow. Orchestrator Agents are built using predefined Atomic Agent and Tool Agent configurations and do not require their own <code>state_model.yml</code>.</li> <li><code>nodes</code>: Lists the agents involved in the workflow.</li> <li><code>edges</code>: Defines the connections between workflow nodes.</li> <li><code>state_field_bindings</code>: Maps the state fields between agents in the workflow.</li> <li><code>conditional_edges</code>: Defines conditional transitions between nodes based on runtime evaluations.</li> </ul>"},{"location":"en/agents/configuration/#example-atomic-agent","title":"Example: Atomic Agent","text":"<pre><code>type: atomic  # atomic, tool, or workflow\nllm:\n  model: openai/gpt-4o-mini # Cusomize the LLM model to use (optional)\n  max_tokens: 2048\n  retry_count: 3\ndescription:\n  - language: en\n    text: An agent for summarizing documents.\ninstructions:\n  - language: en\n    text: Summarize the following text.\nprompt:\n  - language: en\n    template: |\n      {content}\nresponse_fields:\n  - summary\ninput_fields:\n  - content\npost_custom_tool: agent_name.tools.postprocess_summary  # Finalize the summary output\n</code></pre>"},{"location":"en/agents/configuration/#example-tool-agent","title":"Example: Tool Agent","text":"<pre><code>type: tool\ncustom_tool: agents.[agent_name].tools.data_fetcher\nresponse_fields: # state fields that the tool produces or updates\n  - data\ninput_fields: # state fields that the tool expects\n  - url\n  - params\n</code></pre>"},{"location":"en/agents/configuration/#example-workflow-agent","title":"Example: Workflow Agent","text":"<pre><code>type: workflow\nentry_point: data_collector\nnodes:\n  - data_collector\n  - analyzer\n  - summarizer\n\nedges:\n  - from: data_collector\n    to: analyzer\n  - from: analyzer\n    to: summarizer\n\nstate_field_bindings:\n  - from: data_collector.data\n    to: analyzer.input_data\n  - from: analyzer.result.text\n    to: summarizer.context\n\nconditional_edges:\n  - analyzer:\n      condition_function: kagura.conditions.check_analysis\n      conditions:\n        success: summarizer\n        retry: analyzer\n        failure: error_handler\n</code></pre>"},{"location":"en/agents/configuration/#state_modelyml","title":"state_model.yml","text":"<p>The <code>state_model.yml</code> file defines the input, output, and intermediate state fields for the agent. This file is optional for Atomic Agent and Tool Agent and not used by Orchestrator Agent agents.</p>"},{"location":"en/agents/configuration/#example-atomic-agent-state-model","title":"Example: Atomic Agent State Model","text":"<pre><code>custom_models: # You can define own custom models here\n  - name: SummaryData\n    fields:\n      - name: text\n        type: str\n        description:\n          - language: en\n            text: Text to summarize\n      - name: summary\n        type: str\n        description:\n          - language: en\n            text: Generated summary\n\nstate_fields: # Define the state fields used by the agent and tools\n  - name: input_text\n    type: str\n    description:\n      - language: en\n        text: Input text for summarization\n  - name: output_summary\n    type: SummaryData\n    description:\n      - language: en\n        text: Generated summary data\n</code></pre>"},{"location":"en/agents/configuration/#custom-tools","title":"Custom Tools","text":"<p>Custom tools can be used to extend the functionality of agents. These tools should be located in the <code>agent_name/</code> directory and defined in the <code>agent.yml</code> file. You can change the name of <code>tools.py</code> to any other name, but make sure to update the path in the <code>agent.yml</code> file.</p>"},{"location":"en/agents/configuration/#example-custom-tool","title":"Example: Custom Tool","text":"<pre><code>from kagura.core.models import StateModel\n\nasync def fetch_data(state: StateModel) -&gt; StateModel:\n    \"\"\"\n    Custom tool for fetching data from an external API.\n    \"\"\"\n    try:\n        state.data = await external_api_fetch(state.url)\n        return state\n    except Exception as e:\n        raise Exception(f\"Data fetching failed: {str(e)}\")\n</code></pre>"},{"location":"en/agents/configuration/#best-practices","title":"Best Practices","text":"<ul> <li>Keep YAML configurations simple and focused on the agent's specific role.</li> <li>Use descriptive field names and comments to ensure maintainability.</li> <li>Validate your state models using tools like <code>pydantic</code> to avoid runtime errors.</li> <li>Leverage pre- and post-processing hooks to customize state data.</li> </ul>"},{"location":"en/agents/overview/","title":"Overview","text":"<p>Kagura AI Agents are the core building blocks of the Kagura AI system. These modular components enable developers to create flexible, reusable, and scalable workflows for various applications.</p>"},{"location":"en/agents/overview/#what-is-a-kagura-ai-agent","title":"What is a Kagura AI Agent?","text":"<p>A Kagura agent is a self-contained unit designed to:</p> <ul> <li>Perform specific tasks in an AI workflow.</li> <li>Manage state data through YAML-defined models.</li> <li>Interact with other agents via state sharing and orchestration.</li> </ul> <p>Agents are configurable and extensible, making them adaptable to diverse use cases.</p>"},{"location":"en/agents/overview/#core-agent-properties","title":"Core Agent Properties","text":"<ol> <li>Independence: Each agent operates as a standalone module with its own state and logic.</li> <li>Collaboration: Agents can share states and collaborate within workflows.</li> <li>Extensibility: Agents can include custom tools and pre/post-processing hooks.</li> <li>Type Safety: All data is validated using Pydantic models, ensuring consistency.</li> </ol>"},{"location":"en/agents/overview/#agent-types","title":"Agent Types","text":"<p>Kagura offers three primary agent types, each designed for specific use cases:</p> <p>Atomic Agent:</p> <ul> <li>Core stateful agent for LLM tasks.</li> <li>Supports pre- and post-processing hooks for flexibility.</li> <li>Generates structured outputs with type-safe validation.</li> </ul> <p>Tool Agent:</p> <ul> <li>Focuses on non-LLM data processing.</li> <li>Ideal for data transformations, API integrations, and fast execution.</li> </ul> <p>Workflow Agent:</p> <ul> <li>Manages workflows involving multiple agents.</li> <li>Enables conditional routing, error recovery, and progress monitoring.</li> <li>Uses predefined Atomic Agent and Tool Agent to orchestrate tasks.</li> </ul> <p>For a detailed description of each agent type, see the Agent Types document.</p>"},{"location":"en/agents/overview/#agent-configuration","title":"Agent Configuration","text":"<p>Agents are configured using YAML files, which define their roles, state models, and interactions. The basic structure of an agent is as follows:</p> <pre><code>agents/\n\u2514\u2500\u2500 agent_name/\n    \u251c\u2500\u2500 agent.yml         # Core configuration\n    \u251c\u2500\u2500 state_model.yml   # State definition\n    \u2514\u2500\u2500 tools.py          # Custom tools\n</code></pre> <p>To learn more about setting up agents, refer to the Agent Configuration document.</p>"},{"location":"en/agents/overview/#workflow-integration","title":"Workflow Integration","text":"<p>Agents are orchestrated to form complex workflows. The workflow agent handles state sharing, data transformations, and conditional logic between agents. For more information on orchestrating agents, see the Workflow Agent section.</p>"},{"location":"en/agents/overview/#custom-tools","title":"Custom Tools","text":"<p>Agents can be extended with custom tools for specialized tasks. These tools integrate seamlessly into the agent\u2019s lifecycle, providing additional functionality. See the Custom Tool section for more details.</p>"},{"location":"en/agents/overview/#next-steps","title":"Next Steps","text":"<p>To start building with Kagura agents:</p> <ul> <li>Understand the available Agent Types.</li> <li>Learn how to set up Agent Configurations.</li> </ul> <p>These guides will help you effectively utilize Kagura agents in your projects.</p>"},{"location":"en/agents/types/","title":"Agent Types","text":"<p>Kagura provides three core agent types, each tailored for specific tasks and workflows. Understanding these types will help you choose the best one for your project.</p>"},{"location":"en/agents/types/#atomic-agent","title":"Atomic Agent","text":""},{"location":"en/agents/types/#overview","title":"Overview","text":"<p>The Atomic Agent is the foundational building block for stateful AI tasks. It interacts with LLMs and supports flexible configurations for complex processing.</p>"},{"location":"en/agents/types/#key-features","title":"Key Features","text":"<ul> <li>Stateful LLM Processing: Manages input and output states using YAML-defined models.</li> <li>Pre/Post-Processing Hooks: Allows for additional customization before and after LLM interactions.</li> <li>Structured Outputs: Ensures consistency through type-safe validation.</li> </ul>"},{"location":"en/agents/types/#use-cases","title":"Use Cases","text":"<ul> <li>Generating structured content like summaries or reports.</li> <li>Answering complex queries with context-aware responses.</li> <li>Processing multi-step LLM workflows.</li> </ul>"},{"location":"en/agents/types/#example-configuration","title":"Example Configuration","text":"<pre><code># agent.yml\ntype: atomic  # atomic, tool, or workflow\nllm: # Custom LLM configuration for the agent (optional)\n  model: openai/gpt-4o-mini\n  max_tokens: 2048\n  retry_count: 3\ndescription:\n  - language: en\n    text: An agent for summarizing documents.\nprompt:\n  - language: en\n    template: |\n      Summarize: {content}\nresponse_fields:\n  - summary\ninput_fields:\n  - content\n</code></pre>"},{"location":"en/agents/types/#tool-agent","title":"Tool Agent","text":""},{"location":"en/agents/types/#overview_1","title":"Overview","text":"<p>The Tool Agent is designed for tasks that do not involve LLMs. It excels at fast data transformations and external API integrations.</p>"},{"location":"en/agents/types/#key-features_1","title":"Key Features","text":"<ul> <li>No LLM Dependency: Focuses on computational tasks.</li> <li>Fast Execution: Optimized for quick processing.</li> <li>Extensibility: Supports integration with custom tools and APIs.</li> </ul>"},{"location":"en/agents/types/#use-cases_1","title":"Use Cases","text":"<ul> <li>Fetching data from external sources.</li> <li>Transforming or validating structured data.</li> <li>Integrating with external APIs for domain-specific tasks.</li> </ul>"},{"location":"en/agents/types/#example-configuration_1","title":"Example Configuration","text":"<pre><code># agent.yml\ncustom_tool: agent_name.tools.data_fetcher\nresponse_fields:\n  - data  # State fields updated or generated by the tool\ninput_fields:  # State fields required for the tool\n  - url\n  - params\n</code></pre>"},{"location":"en/agents/types/#workflow-agent","title":"Workflow Agent","text":""},{"location":"en/agents/types/#overview_2","title":"Overview","text":"<p>The Workflow Agent coordinates workflows involving multiple agents. It manages state sharing, conditional routing, and error handling across agents.</p>"},{"location":"en/agents/types/#key-features_2","title":"Key Features","text":"<ul> <li>Multi-Agent Workflows: Integrates and coordinates multiple agents (Atomic Agent and Tool Agent) in a single workflow.</li> <li>State Binding: Shares and transfers state between agents seamlessly.</li> <li>Conditional Routing: Supports dynamic transitions between workflow nodes based on runtime conditions.</li> <li>Error Recovery: Handles errors gracefully with retry mechanisms and fallback options.</li> <li>No State Model Requirement: Relies on predefined configurations of Atomic Agent and Tool Agent, eliminating the need for its own <code>state_model.yml</code>.</li> </ul>"},{"location":"en/agents/types/#use-cases_2","title":"Use Cases","text":"<ul> <li>Coordinating a pipeline for document analysis and summarization.</li> <li>Managing workflows that combine data processing and LLM interactions.</li> <li>Implementing complex multi-step decision-making systems.</li> </ul>"},{"location":"en/agents/types/#example-configuration_2","title":"Example Configuration","text":"<pre><code># agent.yml\nentry_point: data_collector\nnodes:\n  - data_collector\n  - analyzer\n  - summarizer\n\nedges:\n  - from: data_collector\n    to: analyzer\n  - from: analyzer\n    to: summarizer\n\nstate_field_bindings:\n  - from: data_collector.data\n    to: analyzer.input_text\n  - from: analyzer.result.text\n    to: summarizer.context\n</code></pre>"},{"location":"en/agents/types/#choosing-the-right-agent","title":"Choosing the Right Agent","text":"Agent Type Use When You Need Atomic Agent Context-aware LLM interactions. Tool Agent Fast data transformations and API calls. Worfklow Agent Complex, multi-step workflows."},{"location":"en/tutorials/agent-publishing-guide/","title":"Kagura Agent Publishing Guide","text":"<p>This guide provides instructions on how to create, test, and publish agents for the Kagura platform.</p>"},{"location":"en/tutorials/agent-publishing-guide/#repository-structure","title":"Repository Structure","text":"<pre><code>kagura-agents/\n\u251c\u2500\u2500 src/\n\u2502   \u2514\u2500\u2500 agent_name/\n\u2502       \u251c\u2500\u2500 agent.yml\n\u2502       \u251c\u2500\u2500 state_model.yml\n\u2502       \u2514\u2500\u2500 tools.py\n\u251c\u2500\u2500 tests/\n\u2502   \u2514\u2500\u2500 agent_name/\n\u2502       \u2514\u2500\u2500 test_agent.py\n\u251c\u2500\u2500 examples/\n\u2502   \u2514\u2500\u2500 agent_name/\n\u2502       \u2514\u2500\u2500 example.py\n\u251c\u2500\u2500 pyproject.toml\n\u251c\u2500\u2500 uv.lock\n\u2514\u2500\u2500 README.md\n</code></pre>"},{"location":"en/tutorials/agent-publishing-guide/#creating-an-agent","title":"Creating an Agent","text":"<p>Before creating a new agent, make sure to install the Kagura CLI and create a new agent template.</p>"},{"location":"en/tutorials/agent-publishing-guide/#building-an-agent","title":"Building An Agent","text":"<p>See: Building Your First Agent</p>"},{"location":"en/tutorials/agent-publishing-guide/#testing-testsagent_nametest_agentpy","title":"Testing (tests/agent_name/test_agent.py)","text":"<pre><code>import pytest\nfrom kagura.core.agent import Agent\n\n@pytest.mark.asyncio\nasync def test_agent():\n    agent = Agent.assigner(\"agent_name\")\n    result = await agent.execute({\n        \"input\": \"test data\"\n    })\n    assert result.SUCCESS\n</code></pre> <p>Make sure to run the tests before publishing the agent. Also see the CONTIBUTING guide for more information.</p> <pre><code>pytest tests/agent_name/test_agent.py\n</code></pre>"},{"location":"en/tutorials/agent-publishing-guide/#example-usage-examplesagent_nameexamplepy","title":"Example Usage (examples/agent_name/example.py)","text":"<pre><code>from kagura.core.agent import Agent\n\nasync def run_example():\n    agent = Agent.assigner(\"agent_name\")\n    result = await agent.execute({\n        \"input\": \"example data\"\n    })\n    print(result.output)\n</code></pre>"},{"location":"en/tutorials/agent-publishing-guide/#agent-documentation-agentsagent_namereadmemd","title":"Agent Documentation (agents/agent_name/README.md)","text":"<pre><code># Agent Name\n\n## Purpose\nBrief description of what the agent does.\n\n## Configuration\nKey configuration options and their meanings.\n\n## Usage\nExample of how to use the agent.\n\n## Dependencies\nList of required packages.\n</code></pre>"},{"location":"en/tutorials/agent-publishing-guide/#publishing","title":"Publishing","text":"<ol> <li> <p>Create GitHub repository <pre><code>git init\ngit add .\ngit commit -m \"Initial commit\"\ngit remote add origin https://github.com/username/kagura-agents.git\ngit push -u origin main\n</code></pre></p> </li> <li> <p>Install agents using Kagura CLI <pre><code>kagura install https://github.com/username/kagura-agents\n</code></pre></p> </li> </ol>"},{"location":"en/tutorials/agent-publishing-guide/#best-practices","title":"Best Practices","text":"<ol> <li> <p>Documentation</p> <ul> <li>Include clear README for each agent</li> <li>Document all configuration options</li> <li>Provide usage examples</li> </ul> </li> <li> <p>Testing</p> <ul> <li>Write unit tests for each agent</li> <li>Include edge cases</li> <li>Test multilingual support</li> </ul> </li> <li> <p>Dependencies</p> <ul> <li>List all requirements</li> <li>Use version constraints</li> <li>Keep dependencies minimal</li> </ul> </li> <li> <p>Code Quality</p> <ul> <li>Follow Python style guide</li> <li>Use type hints</li> <li>Add proper error handling</li> </ul> </li> </ol>"},{"location":"en/tutorials/coding-examples/","title":"Coding Examples","text":"<p>This guide provides practical coding examples for Kagura AI. Each example demonstrates a specific use case and includes complete, runnable code with detailed comments.</p>"},{"location":"en/tutorials/coding-examples/#1-basic-chat-agent-example","title":"1. Basic Chat Agent Example","text":"<p>Simple example of creating a chat interaction with Kagura AI.</p> <pre><code>from kagura.core.agent import Agent\n\nasync def chat():\n    # Initialize the default chat agent\n    # This uses the configuration from ~/.config/kagura/agents/chat/\n    agent = Agent.assigner(\"chat\")\n\n    # Execute the agent with a query and stream the response\n    # Streaming allows real-time display of the agent's response\n    async for response in await agent.execute(\"Who are you?\"):\n        print(response, end=\"\")  # Print each chunk of the response as it arrives\n\n    print()  # Add a newline after completion\n\nif __name__ == \"__main__\":\n    import asyncio\n    # Run the async function in the event loop\n    asyncio.run(chat())\n</code></pre>"},{"location":"en/tutorials/coding-examples/#2-content-fetching-example","title":"2. Content Fetching Example","text":"<p>Example of fetching content from a URL using the content fetcher agent.</p> <p>Copy <code>examples/agents</code> to <code>~/.config/kagura/agents</code> before running this example. Sample scripts are in the <code>examples/scripts</code> directory of the Kagura AI repository.</p> <pre><code>from kagura.core.agent import Agent\nfrom kagura.core.utils.console import KaguraConsole\nfrom kagura.core.models import StateModel\n\nasync def arun(agent_name: str, state: Dict[str, Any]):\n    # Initialize the content fetcher agent with the given state\n    # The state must include a 'url' field for the content source\n    agent = Agent.assigner(agent_name, state)\n\n    # Execute the agent to fetch the content\n    # The agent will handle URL validation and content retrieval\n    result = await agent.execute()\n\n    # Initialize the console for pretty printing\n    # KaguraConsole provides formatted output for better readability\n    console = KaguraConsole()\n\n    # Display the result in a formatted table\n    # model_dump() converts the Pydantic model to a dictionary\n    console.print_data_table(result.model_dump())\n\nif __name__ == \"__main__\":\n    import asyncio\n\n    # Specify the agent and initial state\n    agent_name = \"content_fetcher\"\n    state = {\n        \"url\": \"https://www.kagura-ai.com\"  # URL to fetch content from\n    }\n    # Run the async function\n    asyncio.run(arun(agent_name, state))\n</code></pre>"},{"location":"en/tutorials/coding-examples/#3-content-summarization-example","title":"3. Content Summarization Example","text":"<p>Example of summarizing text content using the summarizer agent.</p> <pre><code>from kagura.core.agent import Agent\nfrom kagura.core.utils.console import KaguraConsole\n\nasync def arun(agent_name: str, state: Dict[str, Any]):\n    # Initialize the summarizer agent with the input text\n    # The state must include content.text field with the text to summarize\n    agent = Agent.assigner(agent_name, state)\n\n    # Execute the agent to generate the summary\n    # The agent will process the text and create a concise summary\n    result = await agent.execute()\n\n    # Initialize the console for formatted output\n    console = KaguraConsole()\n\n    # Display the full result including metadata\n    console.print_data_table(result.model_dump())\n\n    # Print the generated summary separately for clarity\n    print(\"Summary:\")\n    print(result.summary)\n\nif __name__ == \"__main__\":\n    import asyncio\n\n    # Sample text to summarize\n    text = \"\"\"\n    # Kagura AI\n    Kagura is a powerful yet simple AI agent framework that enables you to build,\n    configure, and orchestrate AI agents using YAML files...\n    \"\"\"\n\n    # Configure the agent and state\n    agent_name = \"summarizer\"\n    state = {\n        \"content\": {\n            \"text\": text,  # Text to be summarized\n        }\n    }\n    # Run the async function\n    asyncio.run(arun(agent_name, state))\n</code></pre>"},{"location":"en/tutorials/coding-examples/#4-search-intent-analysis-example","title":"4. Search Intent Analysis Example","text":"<p>Example of analyzing search intents and creating search plans.</p> <pre><code>from kagura.core.agent import Agent\n\nasync def arun():\n    # Configure the search intent extractor\n    agent_name = \"user_search_intent_extractor\"\n    user_query = \"What is the best way to fine-tune the learning rate of an AI model?\"\n\n    # Initialize state with the user's query\n    state = {\"user_query\": user_query}\n\n    # Extract search intents from the query\n    # This agent analyzes the query to understand user's search intentions\n    user_intent_agent = Agent.assigner(agent_name, state)\n    result = await user_intent_agent.execute()\n\n    # Extract the search intents from the result\n    user_search_intents = result.model_dump()[\"user_search_intents\"]\n    print(user_search_intents)\n\n    # Create a search plan based on the extracted intents\n    # The planner agent will create a structured plan for the search\n    state = {\"user_search_intents\": user_search_intents}\n    planner_agent = Agent.assigner(\"search_planner\", state)\n    search_plan = await planner_agent.execute()\n\n    # Display the generated search plan\n    print(search_plan)\n\nif __name__ == \"__main__\":\n    import asyncio\n    # Run the async function\n    asyncio.run(arun())\n</code></pre>"},{"location":"en/tutorials/coding-examples/#5-workflow-integration-example","title":"5. Workflow Integration Example","text":"<p>Example of using a workflow that combines multiple agents.</p> <pre><code>from kagura.core.agent import Agent\nfrom kagura.core.utils.console import KaguraConsole\n\nasync def arun(agent_name: str, state: Dict[str, Any]):\n    # Initialize the workflow agent\n    # This agent coordinates multiple sub-agents in a defined workflow\n    agent = Agent.assigner(agent_name, state)\n\n    # Check if the agent is configured as a workflow\n    if agent.is_workflow:\n        # Initialize console for progress display\n        console = KaguraConsole()\n\n        # Execute the workflow and display updates\n        # The workflow will process through multiple stages\n        async for update in await agent.execute():\n            # Display the state update after each step\n            console.print_data_table(update)\n    else:\n        # Warn if the agent is not a workflow\n        print(f\"{agent_name} is not a workflow agent\")\n\nif __name__ == \"__main__\":\n    import asyncio\n\n    # Configure the workflow\n    agent_name = \"content_summarizer\"  # This workflow fetches and summarizes content\n    state = {\n        \"url\": \"https://github.com\"  # Starting URL for the workflow\n    }\n    # Run the async function\n    asyncio.run(arun(agent_name, state))\n</code></pre> <p>Each example is a complete, standalone script that you can run directly. The comments explain what each part of the code does and why. Make sure you have Kagura AI properly installed and configured before running these examples. For more detailed information about each agent type and their configurations, refer to the full documentation.</p>"},{"location":"en/tutorials/first-agent/","title":"Building Your First Agent: Review Analyzer","text":"<p>This tutorial guides you through creating a review analysis agent that processes customer reviews to extract sentiment, key points, and suggestions.</p>"},{"location":"en/tutorials/first-agent/#project-setup","title":"Project Setup","text":"<ol> <li> <p>Create the agent directory: <pre><code>mkdir -p ~/.config/kagura/agents/review_analyzer\n</code></pre></p> </li> <li> <p>Initialize agent files: <pre><code>touch ~/.config/kagura/agents/review_analyzer/agent.yml\ntouch ~/.config/kagura/agents/review_analyzer/state_model.yml\n</code></pre></p> </li> </ol>"},{"location":"en/tutorials/first-agent/#state-model-configuration","title":"State Model Configuration","text":"<p>Create state_model.yml: <pre><code>custom_models:\n  - name: Sentiment\n    fields:\n      - name: score\n        type: float\n        description:\n          - language: en\n            text: Sentiment score from -1.0 (negative) to 1.0 (positive)\n      - name: confidence\n        type: float\n        description:\n          - language: en\n            text: Confidence level of sentiment analysis (0.0 to 1.0)\n\n  - name: ReviewPoint\n    fields:\n      - name: category\n        type: str\n        description:\n          - language: en\n            text: Category of the point (positive, negative, suggestion)\n      - name: text\n        type: str\n        description:\n          - language: en\n            text: Description of the point\n      - name: importance\n        type: float\n        description:\n          - language: en\n            text: Importance score (0.0 to 1.0)\n\n  - name: AnalysisResult\n    fields:\n      - name: sentiment\n        type: Sentiment\n        description:\n          - language: en\n            text: Overall sentiment analysis\n      - name: key_points\n        type: List[ReviewPoint]\n        description:\n          - language: en\n            text: List of extracted key points\n      - name: suggestions\n        type: List[str]\n        description:\n          - language: en\n            text: Improvement suggestions based on the review\n\nstate_fields:\n  - name: review_text\n    type: str\n    description:\n      - language: en\n        text: Input review text to analyze\n  - name: analysis\n    type: AnalysisResult\n    description:\n      - language: en\n        text: Complete analysis result\n</code></pre></p>"},{"location":"en/tutorials/first-agent/#agent-configuration","title":"Agent Configuration","text":"<p>Create agent.yml: <pre><code>type: atomic\ndescription:\n  - language: en\n    text: Analyzes customer reviews to extract sentiment, key points, and actionable suggestions\n\ninstructions:\n  - language: en\n    description: |\n      Analyze customer reviews to:\n      1. Determine overall sentiment with confidence score\n      2. Extract key positive and negative points\n      3. Generate actionable suggestions\n      4. Assign importance scores to findings\n\n      Maintain objectivity and focus on constructive feedback.\n\nprompt:\n  - language: en\n    template: |\n      Analyze this customer review:\n      {review_text}\n\n      Provide a structured analysis including:\n      1. Overall sentiment (score and confidence)\n      2. Key points (positive and negative)\n      3. Actionable suggestions\n      4. Importance scores for each point\n\n      Focus on specific, actionable insights rather than general observations.\n\nllm:\n  model: openai/gpt-4o-mini\n  max_tokens: 1024\n  retry_count: 3\n\nresponse_fields:\n  - analysis\ninput_fields:\n  - review_text\n</code></pre></p>"},{"location":"en/tutorials/first-agent/#using-the-agent","title":"Using the Agent","text":"<pre><code>from kagura.core.agent import Agent\n\nasync def analyze_review():\n    # Create agent instance\n    agent = Agent.assigner(\"review_analyzer\")\n\n    # Sample review\n    review = \"\"\"\n    The product has great build quality and the battery life is impressive.\n    However, the software is a bit confusing and customer support took too\n    long to respond. Would be better with clearer documentation and faster\n    support response times.\n    \"\"\"\n\n    # Execute analysis\n    result = await agent.execute({\"review_text\": review})\n\n    # Access results\n    analysis = result.analysis\n    print(f\"Sentiment Score: {analysis.sentiment.score}\")\n    print(\"\\nKey Points:\")\n    for point in analysis.key_points:\n        print(f\"- [{point.category}] {point.text} (Importance: {point.importance})\")\n    print(\"\\nSuggestions:\")\n    for suggestion in analysis.suggestions:\n        print(f\"- {suggestion}\")\n\nif __name__ == \"__main__\":\n    import asyncio\n    asyncio.run(analyze_review())\n</code></pre>"},{"location":"en/tutorials/first-agent/#testing","title":"Testing","text":"<pre><code>import pytest\nfrom kagura.core.agent import Agent\n\n@pytest.mark.asyncio\nasync def test_review_analyzer():\n    agent = Agent.assigner(\"review_analyzer\")\n    test_review = \"Good product but needs improvement in user interface...\"\n\n    result = await agent.execute({\"review_text\": test_review})\n\n    assert result.SUCCESS\n    assert -1.0 &lt;= result.analysis.sentiment.score &lt;= 1.0\n    assert 0.0 &lt;= result.analysis.sentiment.confidence &lt;= 1.0\n    assert len(result.analysis.key_points) &gt; 0\n    assert len(result.analysis.suggestions) &gt; 0\n\n@pytest.mark.asyncio\nasync def test_empty_review():\n    agent = Agent.assigner(\"review_analyzer\")\n\n    result = await agent.execute({\"review_text\": \"\"})\n    assert not result.SUCCESS\n    assert result.ERROR_MESSAGE\n</code></pre>"}]}