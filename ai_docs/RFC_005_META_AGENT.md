# RFC-005: Meta Agent (AI Agent Builder)

## ステータス
- **状態**: Draft
- **作成日**: 2025-10-04
- **関連Issue**: TBD
- **優先度**: High

## 概要

「AIエージェントを作るAI」を実装します。ユーザーが自然言語で「こういうエージェントが欲しい」と伝えるだけで、Kaguraが自動的にエージェントコードを生成、テスト、デプロイします。

### 目標
- 自然言語からエージェントコード自動生成
- インタラクティブなエージェント設計プロセス
- 生成されたエージェントのテスト自動化
- エージェントのバージョン管理とデプロイ
- エージェント間の依存関係管理

### 非目標
- ノーコードGUIエディタ（将来的に検討）
- エージェントのマーケットプレイス（将来的に検討）

## モチベーション

### 現在の課題
1. エージェント作成には`@agent`デコレータの理解が必要
2. ツール定義、プロンプト設計、エラーハンドリングなど学習コスト高い
3. 似たようなエージェントを何度も書く非効率性

### 解決するユースケース
- 「GitHubのissueを週次レポートにまとめるエージェント作って」
- 「Slackメッセージを分析して重要度を判定するエージェント作って」
- 「毎朝天気とニュースを要約して通知するエージェント作って」

### なぜ今実装すべきか
- GPT-4oなど高性能コード生成モデルの登場
- Kagura自体のAPIが安定（v2.0.0-beta.1リリース済み）
- ユーザーが実装したい機能の多様性増加

## 設計

### アーキテクチャ

```
┌──────────────────────────────────────────────┐
│         Meta Agent Interface                 │
│                                              │
│  ┌────────────────────────────────────────┐ │
│  │  Natural Language Agent Spec Parser    │ │
│  │  - Intent extraction                   │ │
│  │  - Tool requirements analysis          │ │
│  │  - Workflow detection                  │ │
│  └───────────────┬────────────────────────┘ │
│                  │                          │
│                  ▼                          │
│  ┌────────────────────────────────────────┐ │
│  │      Agent Code Generator              │ │
│  │  - Template selection                  │ │
│  │  - @agent/@tool/@workflow generation   │ │
│  │  - Test generation                     │ │
│  └───────────────┬────────────────────────┘ │
│                  │                          │
│                  ▼                          │
│  ┌────────────────────────────────────────┐ │
│  │       Agent Validator                  │ │
│  │  - Syntax checking (pyright)           │ │
│  │  - Test execution (pytest)             │ │
│  │  - Security scanning                   │ │
│  └───────────────┬────────────────────────┘ │
│                  │                          │
│                  ▼                          │
│  ┌────────────────────────────────────────┐ │
│  │      Agent Deployer                    │ │
│  │  - File generation                     │ │
│  │  - Dependency installation             │ │
│  │  - CLI registration                    │ │
│  └────────────────────────────────────────┘ │
└──────────────────────────────────────────────┘
```

### コンポーネント設計

#### 1. Agent Builder CLI

```bash
# エージェント作成ウィザード
kagura build agent

What do you want your agent to do?
> 毎朝7時に天気とニュースを要約してSlackに投稿する

Great! I'll create a morning briefing agent.

What should we name it?
> morning_briefing

What tools does it need? (auto-detected: weather_api, news_api, slack)
> [Enter to accept]

Should it run on a schedule?
> yes

Cron expression (default: 0 7 * * *):
> [Enter to accept]

Generating agent code... ✓
Running tests... ✓
Installing dependencies... ✓

Your agent is ready! Try:
  kagura run morning_briefing
  kagura schedule morning_briefing --cron "0 7 * * *"

Agent saved to: ~/.kagura/agents/morning_briefing.py
```

#### 2. Meta Agent API

```python
from kagura import meta

# 自然言語からエージェント生成
agent_code = await meta.build_agent(
    description="Slack messages to priority score",
    name="slack_prioritizer",
    tools=["slack_api"],
    output_type="json"
)

# エージェントファイル生成
agent_path = await meta.create_agent_file(
    code=agent_code,
    path="~/.kagura/agents/slack_prioritizer.py"
)

# テスト生成と実行
test_result = await meta.test_agent(agent_path)
assert test_result.passed

# デプロイ
await meta.deploy_agent(agent_path)
```

#### 3. Interactive Agent Design

```python
from kagura import meta

# 対話的エージェント設計
builder = meta.AgentBuilder()

# ステップ1: 目的定義
builder.set_goal("GitHub issues weekly report")

# ステップ2: 入力/出力定義
builder.set_input({"repo": "str", "since_days": "int"})
builder.set_output("markdown report")

# ステップ3: ツール選択
available_tools = builder.suggest_tools()
# => ["github_api", "markdown_formatter", "email_sender"]
builder.add_tools(["github_api", "markdown_formatter"])

# ステップ4: ワークフロー設計
builder.set_workflow([
    "Fetch issues from GitHub",
    "Group by label and priority",
    "Generate markdown summary",
    "Send via email"
])

# ステップ5: コード生成
agent_code = await builder.generate()
print(agent_code)
```

### 生成されるエージェントコード例

#### 例1: Morning Briefing Agent

**ユーザー入力:**
```
毎朝7時に天気とニュースを要約してSlackに投稿する
```

**生成されるコード:**
```python
# ~/.kagura/agents/morning_briefing.py
"""
Morning Briefing Agent
Auto-generated by Kagura Meta Agent on 2025-10-04
"""

from kagura import agent, tool, workflow
from datetime import datetime
import requests
import os

@tool
def get_weather(city: str = "Tokyo") -> dict:
    """Get current weather for a city"""
    api_key = os.getenv("OPENWEATHER_API_KEY")
    url = f"https://api.openweathermap.org/data/2.5/weather?q={city}&appid={api_key}"
    response = requests.get(url)
    return response.json()

@tool
def get_news(category: str = "technology", count: int = 5) -> list:
    """Get latest news articles"""
    api_key = os.getenv("NEWS_API_KEY")
    url = f"https://newsapi.org/v2/top-headlines?category={category}&pageSize={count}&apiKey={api_key}"
    response = requests.get(url)
    return response.json()["articles"]

@tool
def post_to_slack(message: str, channel: str = "#general") -> bool:
    """Post message to Slack"""
    webhook_url = os.getenv("SLACK_WEBHOOK_URL")
    response = requests.post(webhook_url, json={"text": message, "channel": channel})
    return response.status_code == 200

@agent(model="gpt-4o-mini")
@workflow.chain
async def morning_briefing() -> str:
    """
    Generate morning briefing with weather and news.

    Steps:
    1. Get current weather
    2. Get latest news
    3. Summarize in Japanese
    4. Post to Slack
    """
    # Get data
    weather = get_weather("Tokyo")
    news = get_news("technology", 5)

    # Format briefing
    briefing = f"""
    おはようございます！{datetime.now().strftime('%Y年%m月%d日')}の情報です。

    **天気**
    {weather['weather'][0]['description']}, {weather['main']['temp']}°C

    **ニュース**
    """

    for i, article in enumerate(news, 1):
        briefing += f"{i}. {article['title']}\n"

    return briefing

@workflow.schedule(cron="0 7 * * *")
async def scheduled_briefing():
    """Run morning briefing at 7 AM daily"""
    briefing = await morning_briefing()
    post_to_slack(briefing, "#general")
    return "Briefing posted successfully"

if __name__ == "__main__":
    import asyncio
    asyncio.run(scheduled_briefing())
```

**生成されるテストコード:**
```python
# tests/test_morning_briefing.py
import pytest
from unittest.mock import patch, MagicMock
from kagura.agents.morning_briefing import morning_briefing, get_weather, get_news

@pytest.mark.asyncio
async def test_morning_briefing():
    with patch('kagura.agents.morning_briefing.get_weather') as mock_weather, \
         patch('kagura.agents.morning_briefing.get_news') as mock_news:

        mock_weather.return_value = {
            "weather": [{"description": "晴れ"}],
            "main": {"temp": 20}
        }
        mock_news.return_value = [
            {"title": "AI News 1"},
            {"title": "AI News 2"}
        ]

        result = await morning_briefing()

        assert "おはようございます" in result
        assert "晴れ" in result
        assert "AI News 1" in result

def test_get_weather():
    # Mock API call
    with patch('requests.get') as mock_get:
        mock_get.return_value.json.return_value = {"main": {"temp": 20}}
        result = get_weather("Tokyo")
        assert result["main"]["temp"] == 20
```

#### 例2: GitHub Issue Reporter

**ユーザー入力:**
```
GitHubのissueを週次レポートにまとめて、優先度順にソートして、マークダウンで出力
```

**生成されるコード:**
```python
# ~/.kagura/agents/github_issue_reporter.py
from kagura import agent, tool
from github import Github
from datetime import datetime, timedelta
import os

@tool
def fetch_github_issues(repo: str, since_days: int = 7) -> list:
    """Fetch GitHub issues from the last N days"""
    g = Github(os.getenv("GITHUB_TOKEN"))
    repository = g.get_repo(repo)
    since = datetime.now() - timedelta(days=since_days)

    issues = repository.get_issues(
        state="all",
        since=since,
        sort="created",
        direction="desc"
    )

    return [
        {
            "number": issue.number,
            "title": issue.title,
            "state": issue.state,
            "labels": [label.name for label in issue.labels],
            "created_at": issue.created_at.isoformat(),
            "comments": issue.comments
        }
        for issue in issues
    ]

@agent(model="gpt-4o-mini")
async def github_issue_reporter(repo: str, since_days: int = 7) -> str:
    """
    Generate a weekly GitHub issue report.

    Args:
        repo: Repository name (e.g., "owner/repo")
        since_days: Number of days to look back

    Returns:
        Markdown formatted report with issues sorted by priority
    """
    issues = fetch_github_issues(repo, since_days)

    # Analyze and format
    prompt = f"""
    以下のGitHub issueを分析して、週次レポートを作成してください：

    {issues}

    要件:
    1. 優先度順にソート（ラベル"priority:high"優先）
    2. マークダウン形式
    3. 各issueの要約を含める
    4. 統計情報（オープン数、クローズ数、コメント数）
    """

    # LLMが自動的にレポート生成
    return prompt

if __name__ == "__main__":
    import asyncio
    report = asyncio.run(github_issue_reporter("anthropics/kagura-ai", 7))
    print(report)
```

### 統合例

#### インタラクティブビルダーの完全な例

```python
from kagura import meta
from kagura.meta import AgentBuilder

# Step-by-step agent building
async def build_custom_agent():
    builder = AgentBuilder()

    # Step 1: Define goal
    goal = input("What should your agent do? ")
    builder.set_goal(goal)

    # Step 2: AI suggests architecture
    suggestions = await builder.analyze_goal()
    print(f"\nI suggest:")
    print(f"  - Model: {suggestions['model']}")
    print(f"  - Tools: {', '.join(suggestions['tools'])}")
    print(f"  - Workflow: {suggestions['workflow_type']}")

    # Step 3: User customization
    if input("\nCustomize? (y/n): ").lower() == 'y':
        builder.set_model(input("Model: ") or suggestions['model'])
        tools = input("Tools (comma-separated): ") or ','.join(suggestions['tools'])
        builder.add_tools(tools.split(','))
    else:
        builder.apply_suggestions(suggestions)

    # Step 4: Generate code
    print("\nGenerating agent code...")
    code = await builder.generate()

    # Step 5: Review
    print("\nGenerated code:")
    print(code)

    if input("\nLooks good? (y/n): ").lower() == 'y':
        # Step 6: Save and test
        name = input("Agent name: ")
        path = await builder.save(name)

        print(f"\nTesting {name}...")
        test_result = await builder.test()

        if test_result.passed:
            print("✓ Tests passed!")
            await builder.deploy()
            print(f"✓ Agent deployed to {path}")
        else:
            print(f"✗ Tests failed:\n{test_result.errors}")
            if input("Debug? (y/n): ").lower() == 'y':
                await builder.debug_agent()

    return builder.agent_path

# Run builder
if __name__ == "__main__":
    import asyncio
    asyncio.run(build_custom_agent())
```

#### プログラマティックなエージェント生成

```python
from kagura import meta

# Batch agent generation
agents_to_create = [
    {
        "name": "email_summarizer",
        "description": "Summarize unread emails daily",
        "schedule": "0 9 * * *",
        "tools": ["gmail_api"]
    },
    {
        "name": "code_reviewer",
        "description": "Review GitHub PRs for code quality",
        "triggers": ["github_webhook"],
        "tools": ["github_api", "pyright"]
    },
    {
        "name": "expense_tracker",
        "description": "Track expenses from receipts (OCR)",
        "tools": ["tesseract", "sqlite"],
        "multimodal": True
    }
]

for spec in agents_to_create:
    agent = await meta.build_agent(**spec)
    await meta.deploy_agent(agent)
    print(f"✓ {spec['name']} created")
```

## 実装計画

### Phase 1: 基本ビルダー (v2.2.0)
- [ ] `kagura build agent` コマンド実装
- [ ] 自然言語からエージェント仕様抽出
- [ ] テンプレートベースのコード生成
- [ ] 基本的なツール自動検出

### Phase 2: 高度な生成 (v2.3.0)
- [ ] ワークフロー自動設計
- [ ] カスタムツール生成
- [ ] テストコード自動生成
- [ ] インタラクティブビルダーUI

### Phase 3: 最適化とバリデーション (v2.4.0)
- [ ] 生成コードの静的解析
- [ ] セキュリティスキャン
- [ ] パフォーマンス最適化提案
- [ ] ベストプラクティスチェック

### Phase 4: エージェント管理 (v2.5.0)
- [ ] エージェントバージョン管理
- [ ] エージェント間依存関係管理
- [ ] エージェントマーケットプレイス（コミュニティ共有）
- [ ] エージェントアップデートシステム

## 技術的詳細

### 依存関係

```toml
[project.optional-dependencies]
meta = [
    "jinja2>=3.1.2",           # Template engine
    "astor>=0.8.1",            # AST manipulation
    "black>=23.12.0",          # Code formatting
    "pyright>=1.1.338",        # Type checking
    "libcst>=1.1.0",           # Code transformation
]
```

### エージェントテンプレート

```python
# kagura/meta/templates/basic_agent.py.j2
"""
{{ agent_name }}
{{ agent_description }}

Auto-generated by Kagura Meta Agent on {{ generation_date }}
"""

from kagura import agent{% if has_tools %}, tool{% endif %}{% if has_workflow %}, workflow{% endif %}
{% for import in custom_imports %}
{{ import }}
{% endfor %}

{% for tool_def in tools %}
@tool
{{ tool_def.code }}

{% endfor %}

@agent(model="{{ model }}")
{% if workflow_type %}
@workflow.{{ workflow_type }}
{% endif %}
async def {{ agent_name }}({{ parameters }}) -> {{ return_type }}:
    """
    {{ docstring }}

    Args:
    {% for param in params %}
        {{ param.name }}: {{ param.description }}
    {% endfor %}

    Returns:
        {{ return_description }}
    """
    {{ agent_body }}

{% if has_schedule %}
@workflow.schedule(cron="{{ cron_expression }}")
async def scheduled_{{ agent_name }}():
    """Scheduled execution of {{ agent_name }}"""
    return await {{ agent_name }}({{ default_args }})
{% endif %}

if __name__ == "__main__":
    import asyncio
    result = asyncio.run({{ agent_name }}({{ example_args }}))
    print(result)
```

### コード生成プロンプト

```python
# kagura/meta/prompts.py

AGENT_GENERATION_PROMPT = """
You are an expert Python developer specializing in AI agent development with Kagura.

User wants to create an agent that:
{{ user_description }}

Generate a complete, production-ready Kagura agent that:
1. Uses the @agent decorator with appropriate model
2. Defines any necessary @tool functions
3. Implements proper error handling
4. Includes type hints
5. Has comprehensive docstrings
6. Follows Python best practices

Available tools: {{ available_tools }}
Kagura version: {{ kagura_version }}

Output ONLY the Python code, no explanations.
"""

TOOL_DETECTION_PROMPT = """
Analyze this agent description and suggest appropriate tools:

Description: {{ description }}

Available tool categories:
- APIs: github, slack, gmail, calendar, drive, notion, twitter
- Data: sqlite, postgresql, redis, csv, json
- Processing: ocr, image, audio, video, pdf
- Utilities: http, file_system, email, crypto

Output JSON:
{
  "required_tools": ["tool1", "tool2"],
  "optional_tools": ["tool3"],
  "custom_tools_needed": ["custom_tool_description"]
}
"""
```

### セキュリティスキャン

```python
from kagura.meta import SecurityScanner

scanner = SecurityScanner()

# 生成されたコードのスキャン
issues = scanner.scan_code(agent_code)

for issue in issues:
    print(f"{issue.severity}: {issue.message}")
    print(f"  Line {issue.line}: {issue.code_snippet}")

# 一般的なチェック:
# - eval/exec の使用
# - ハードコードされたシークレット
# - SQLインジェクションリスク
# - ファイルシステムアクセスの安全性
# - 外部コマンド実行
```

## テスト戦略

### ユニットテスト

```python
# tests/meta/test_agent_builder.py
import pytest
from kagura.meta import AgentBuilder

@pytest.mark.asyncio
async def test_agent_generation():
    builder = AgentBuilder()
    builder.set_goal("Summarize news articles")
    builder.add_tools(["news_api"])

    code = await builder.generate()

    assert "@agent" in code
    assert "async def" in code
    assert "news_api" in code

@pytest.mark.asyncio
async def test_tool_detection():
    builder = AgentBuilder()
    builder.set_goal("Fetch GitHub issues and post to Slack")

    tools = await builder.suggest_tools()

    assert "github_api" in tools
    assert "slack_api" in tools
```

### 統合テスト

```python
# tests/meta/test_generated_agent.py
import pytest
from kagura import meta
import tempfile
import subprocess

@pytest.mark.asyncio
async def test_generated_agent_execution():
    # Generate agent
    agent_code = await meta.build_agent(
        description="Add two numbers",
        name="simple_adder"
    )

    # Save to temp file
    with tempfile.NamedTemporaryFile(mode='w', suffix='.py', delete=False) as f:
        f.write(agent_code)
        agent_file = f.name

    # Run generated agent
    result = subprocess.run(
        ["python", agent_file],
        input="3\n5\n",
        capture_output=True,
        text=True
    )

    assert "8" in result.stdout or "8" in result.stderr
```

## マイグレーション

既存ユーザーへの影響なし。Meta Agent機能は新規追加：

```bash
# Meta Agent機能のインストール
pip install kagura-ai[meta]

# 最初のエージェント作成
kagura build agent
```

## ドキュメント

### 必要なドキュメント
1. Agent Builder クイックスタートガイド
2. エージェントテンプレート リファレンス
3. カスタムツール作成ガイド
4. 生成されたエージェントのカスタマイズ方法
5. ベストプラクティスとパターン集

### サンプルコード
- 定期実行エージェント（cron）
- Webhookトリガーエージェント
- マルチモーダルエージェント
- エージェント連携パターン

## 代替案

### 案1: ノーコードWebエディタ
- GUIでドラッグ&ドロップでエージェント作成
- **却下理由**: 開発工数大、Kaguraのコード重視思想と不一致

### 案2: YAMLベース設定
- YAML/TOMLファイルでエージェント定義
- **却下理由**: 柔軟性が低い、デバッグ困難

### 案3: DSL（Domain Specific Language）
- Kagura専用の言語を作成
- **却下理由**: 学習コスト高、Pythonエコシステムから乖離

## 未解決の問題

1. **生成コードの品質保証**
   - LLMの出力は非決定的
   - 複雑なロジックの生成精度

2. **カスタムツールの自動生成**
   - 既存APIラッパーがない場合の対処
   - API仕様からツールコード生成

3. **エージェント間依存関係**
   - あるエージェントが別のエージェントを呼ぶ場合
   - 循環依存の検出

## 参考資料

- [GitHub Copilot Workspace](https://github.com/features/copilot)
- [Cursor](https://cursor.sh/)
- [v0.dev](https://v0.dev/)
- [Anthropic Claude Artifacts](https://www.anthropic.com/claude)

## 改訂履歴

- 2025-10-04: 初版作成
